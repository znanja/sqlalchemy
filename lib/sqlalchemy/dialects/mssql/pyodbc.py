"""
Support for MS-SQL via pyodbc.

http://pypi.python.org/pypi/pyodbc/

Connect strings are of the form::

    mssql+pyodbc://<username>:<password>@<dsn>/
    mssql+pyodbc://<username>:<password>@<host>/<database>


"""

from sqlalchemy.dialects.mssql.base import MSExecutionContext, MSDialect
from sqlalchemy.connectors.pyodbc import PyODBCConnector, PyODBCNumeric
from sqlalchemy import types as sqltypes, util

class _MSNumeric_pyodbc(PyODBCNumeric):
    pass
    
class MSExecutionContext_pyodbc(MSExecutionContext):
    _embedded_scope_identity = False
    
    def pre_exec(self):
        """where appropriate, issue "select scope_identity()" in the same statement.
        
        Background on why "scope_identity()" is preferable to "@@identity":
        http://msdn.microsoft.com/en-us/library/ms190315.aspx
        
        Background on why we attempt to embed "scope_identity()" into the same
        statement as the INSERT:
        http://code.google.com/p/pyodbc/wiki/FAQs#How_do_I_retrieve_autogenerated/identity_values?
        
        """
        
        super(MSExecutionContext_pyodbc, self).pre_exec()

        # don't embed the scope_identity select into an "INSERT .. DEFAULT VALUES"
        if self._select_lastrowid and \
                self.dialect.use_scope_identity and \
                len(self.parameters[0]):
            self._embedded_scope_identity = True
            
            self.statement += "; select scope_identity()"

    def post_exec(self):
        if self._embedded_scope_identity:
            # Fetch the last inserted id from the manipulated statement
            # We may have to skip over a number of result sets with no data (due to triggers, etc.)
            while True:
                try:
                    # fetchall() ensures the cursor is consumed 
                    # without closing it (FreeTDS particularly)
                    row = self.cursor.fetchall()[0]  
                    break
                except self.dialect.dbapi.Error, e:
                    # no way around this - nextset() consumes the previous set
                    # so we need to just keep flipping
                    self.cursor.nextset()
                    
            self._lastrowid = int(row[0])
        else:
            super(MSExecutionContext_pyodbc, self).post_exec()


class MSDialect_pyodbc(PyODBCConnector, MSDialect):

    execution_ctx_cls = MSExecutionContext_pyodbc

    pyodbc_driver_name = 'SQL Server'
    
    colspecs = util.update_copy(
        MSDialect.colspecs,
        {
            sqltypes.Numeric:_MSNumeric_pyodbc
        }
    )
    
    def __init__(self, description_encoding='latin-1', **params):
        super(MSDialect_pyodbc, self).__init__(**params)
        self.description_encoding = description_encoding
        self.use_scope_identity = self.dbapi and hasattr(self.dbapi.Cursor, 'nextset')
        
dialect = MSDialect_pyodbc
